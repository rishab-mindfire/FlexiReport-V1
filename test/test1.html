<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JSON → PDF Engine (Header, Footer, Grouping)</title>

    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>

    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont;
        background: #f0f2f5;
        padding: 20px;
      }
      button {
        padding: 12px 24px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
      }
      #status {
        margin-top: 10px;
        font-size: 13px;
      }
      iframe {
        width: 100%;
        height: 800px;
        border: 1px solid #ccc;
        margin-top: 20px;
        background: white;
      }
    </style>
  </head>

  <body>
    <button onclick="generatePdfFromJson(reportJson)">Generate PDF</button>

    <div id="status"></div>
    <iframe id="preview"></iframe>

    <script>
      /*********************************************************
       * SINGLE RESPONSIBILITY FUNCTION
       * JSON → PDF (Header + Footer + Grouping)
       *********************************************************/
      async function generatePdfFromJson(report) {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'pt', report.meta.pageSize || 'a4');

        const status = document.getElementById('status');
        const preview = document.getElementById('preview');

        const CHUNK_SIZE = 6000;
        let processed = 0;

        let currentGroup = null;
        let groupTotal = 0;

        while (processed < report.rows.length) {
          const chunk = report.rows.slice(processed, processed + CHUNK_SIZE);

          const bodyRows = [];

          for (const row of chunk) {
            // ---- GROUP HEADER ----
            if (
              report.grouping.enabled &&
              row[report.grouping.field] !== currentGroup
            ) {
              // Subtotal for previous group
              if (currentGroup !== null && report.grouping.showSubtotal) {
                bodyRows.push([
                  '',
                  `Subtotal (${currentGroup})`,
                  '',
                  groupTotal.toFixed(2),
                ]);
                groupTotal = 0;
              }

              currentGroup = row[report.grouping.field];

              bodyRows.push([
                {
                  content: `Region: ${currentGroup}`,
                  colSpan: report.columns.length,
                  styles: {
                    fontStyle: 'bold',
                    fillColor: [230, 230, 230],
                  },
                },
              ]);
            }

            // ---- DATA ROW ----
            bodyRows.push(report.columns.map((c) => row[c.key]));

            if (report.grouping.enabled) {
              groupTotal += Number(row.amount);
            }
          }

          status.innerText = `Processing ${processed.toLocaleString()} / ${report.rows.length.toLocaleString()} rows`;

          doc.autoTable({
            head: processed === 0 ? [report.columns.map((c) => c.label)] : null,

            body: bodyRows,

            startY: processed === 0 ? 90 : doc.lastAutoTable.finalY,

            margin: {
              top: report.header.height,
              bottom: report.footer.height,
              left: 40,
              right: 40,
            },

            styles: {
              fontSize: 7,
              cellPadding: 2,
            },

            theme: 'grid',

            didDrawPage: function () {
              // ---------- HEADER ----------
              doc.setFontSize(11);
              doc.text(report.meta.title, 40, 40);

              doc.setFontSize(8);
              doc.text(
                `Generated: ${report.meta.generatedAt}`,
                doc.internal.pageSize.width - 40,
                40,
                { align: 'right' },
              );

              // ---------- FOOTER ----------
              const page = doc.internal.getCurrentPageInfo().pageNumber;
              doc.setFontSize(8);
              doc.text(
                `Page ${page}`,
                doc.internal.pageSize.width / 2,
                doc.internal.pageSize.height - 20,
                { align: 'center' },
              );
            },
          });

          processed += CHUNK_SIZE;

          // Yield browser control (critical)
          await new Promise((r) => setTimeout(r, 20));
        }

        // Final group subtotal
        if (report.grouping.enabled && report.grouping.showSubtotal) {
          doc.autoTable({
            body: [
              ['', `Subtotal (${currentGroup})`, '', groupTotal.toFixed(2)],
            ],
            startY: doc.lastAutoTable.finalY,
          });
        }

        status.innerText = 'Finalizing PDF…';

        const url = doc.output('bloburl');
        preview.src = url;

        status.innerText = 'PDF ready (preview & download enabled)';
      }

      /*********************************************************
       * SAMPLE JSON (Replace with FileMaker / API data)
       * IMPORTANT: rows must be sorted by grouping field
       *********************************************************/
      const reportJson = {
        meta: {
          title: 'Customer Transaction Report',
          generatedAt: new Date().toLocaleString(),
          pageSize: 'a4',
        },

        header: { height: 70 },
        footer: { height: 30 },

        grouping: {
          enabled: true,
          field: 'region',
          showSubtotal: true,
        },

        columns: [
          { key: 'id', label: 'ID', width: 40 },
          { key: 'name', label: 'Customer Name' },
          { key: 'region', label: 'Region' },
          { key: 'amount', label: 'Amount', align: 'right' },
        ],

        rows: Array.from({ length: 550000 }, (_, i) => ({
          id: i + 1,
          name: `Customer ${i + 1}`,
          region: ['North', 'South', 'East', 'West'][Math.floor(i / 12500)],
          amount: +(Math.random() * 500).toFixed(2),
        })),
      };
    </script>
  </body>
</html>
